cf. ook http://blog.ianbicking.org/little-apps-instead-of-little-frameworks.html
cf. laatste slides van "Cowboy development in Django" van Simon Willison waarin hij webdev in 2005 vergelijkt met webdev in 2009

http://discuss.joelonsoftware.com/default.asp?joel.3.219431.12

"I don't want to use any framework at all.

I know what several of you are thinking. I'd be out of my mind not to use some sort of framework. Am I honestly thinking of writing every single line of code that I'll need all on my own?

No, of course not.

What I'd really like to find are some appropriate *libraries* that I can use to provide several kinds of functionality for my project."

A website as a bunch of components
----------------------------------

[Mijn blogpost meer structureren in de zin van "allerlei dingen die ik hier zie die mensen uitproberen" + "mijn eigen ervaringen die dit corroboreren" plus dit een beetje abstraheren tot een coherente methode, maar mensen zijn al heel lang met het probleem en met "Application lifecycle management" bezig.]

Websites are becoming more complex every day. Frameworks make it easier than ever to create feature-rich websites quickly, but our collective wish to push the envelope keeps tugging in the other direction. I'm talking about "faceted search", "real-time updates", all kinds of "javascript candy", advanced "caching" and "performance tuning", "single sign-on" between different parts of your infrastructure and so on.

Web frameworks kan keep things manageable, but to get the most out of them, they really require you to consolidate your infrastructure and place all bets on a single programming language, a single framework and a single way of doing things. The problem with that, though, is that it can stifle much-needed innovation. Marc Frons, CTO for the digital infrastructure of the New York Times mentions how he goes about selecting a technology stack for a project: 

bq. That is where my guys were comfortable with. Those were the technologies they liked. They proved to me they could make them work. I wasn’t about to tell them they had to use something they were opposed to using.

Dictating a certain technology that all employees must use, whatever the situation or project they are faced with, kills motivation. Yet telling engineers what technologies they can and can not use is exactly what happens when settling on a specific platform. The team might have had a say in the initial decision, or perhaps even made the decision autonomously, but once that platform decision is made, their breathing room and room to experiment will be severy limited.

At an undisclosed point in the future, developers will start getting unhappy with the established way of doing things, and if their discontent reaches a critical level, a switch to another platform is orchestrated. Of course, because at this point all working parts of your infrastructure are written for the platform you'll be abandoning, all decisions about the successor are based on experience that is limited to hobby projects and small-scale implementations. Wouldn't it be a good bit easier to make such decisions if the technology was already in production use, powering part of the site. That way, you'd merely be deciding to expand upon earlier successes, not to switch to something entirely new because your old thing sucks.

On top of that, adding new functionality to a web site brings with it an uncomfortable dilemma.

bq. For example, you may want to add a blog. Do you:

# Use the best blogging software available?
# Use something native to your platform?
# Write something yourself?

The answer is probably 2 or 3, because it would be too hard to integrate something foreign to your platform. This form of choice means that every platform has some kind of “blog”, but the users of that blog are likely to only be a subset of the users of the parent platform. This makes it difficult for winners to emerge, or for a well-developed piece of software to really be successful. (http://deliverance.openplans.org/philosophy.html)

Everybody loves Wordpress. It's great. Yet we're confronted with a whole host of clones in "Django" and "Ruby on Rails" that don't compare favorably to Wordpress _at all_. And still they get used, because we'd rather have a blogging app that integrates with our existing environment, rather than having to mish-mash a bunch of different technologies and platforms. Rightly so. Ian Bicking again sums up some of the advantages to using a central platform: 

# A common look-and-feel across the site.
# Cohesive navigation.
# Indexing of the entire site.
# Shared authentication and user accounts.
# Cross-cutting functionality (e.g., commenting).

But centralised development means we're missing opportunities. We can't use programming languages, frameworks and software packages that are particularly suited to a specific problem, because we have to insist on a single one-size-fits-all platform if we want to avoid having a site that looks and functions like a digital patchwork.

This situation first presented itself to me when I was still working at the "student newspaper" here in Ghent. I spent a lot of time building up an infrastructure based around "Drupal"http://drupal.org/. That means: a digital newsroom, internal documentation, a database that contained all of our advertisers, user management and integration with postfix, integration with InDesign to aid in producing our printed magazine. Oh, and it also included a front-facing website.

It's a platform that has served the newspaper well, but it was not without its shortcomings.

For one, you use the stuff that's there, even if it's not best of breed. The CRM-part of the website was limited to a database of possible advertisers in the paper, and a short note on when they were last contacted. At that time, having the database available on our intranet was a big win to having it hidden away in an excelfile that always seemed to disappear when it was most needed. But as far as custumer relationship management goes, it was pathetic.

Upgrades posed a second problem. Because our central installation contained all the building blocks for our internal workflow at the student newspaper, upgrades became all-or-nothing. At some point in 2008 we released a subsite with study advice for new students. I was hankering to try out all the cool new stuff in Drupal 6, but switching that subsite to Drupal 6 would have meant migrating the _entire_ install — intranet, newsroom, crm and all — to that new version, just to be able to experiment a bit with our study guide website and to be able to try new things. And because upgrading everything would have entailed quite a bit of work, we just stuck with Drupal 5. And Drupal 5 is still the version in use at the student newspaper, to this very day.

A third problem, which follows on the second, is that such a big monolithic beast of a system will kill motivation before you know it. This was particularly noticeable at the student newspaper, because it relies on volunteers. Getting people to code for _us_ without renumeration, instead of contributing to one of the multitude of interesting open source projects that are around, was hard enough. Getting people to code for zilch while at the same time forcing them to work with a platform that is more or less cast in stone and that takes considerable time to get up to speed is nigh impossible. The barrier to entry suddenly gets raised from "I'll cobble together some flash to illustrate these articles" to "please check the docs for basic Drupal modules like Panels, CCK and Views, then get familiar with modifying Drupal both in its execution and at the theme layer, learn a bit about all the API's. When you're done you can code your work as a Drupal module." Really, there is nothing to it!

Wouldn't it be better if we could just mix technologies at will, while keeping a bit of the centralisation and unification that makes programming to a platform so genuinely useful?

I don't have a solution to the platform problem that Ian Bicking has so eloquently described, but I do believe I've found part of the puzzle. And that part is to stop thinking in terms of "a website" and start thinking of a web-based project as a bunch of separate but interacting components that serve as a basic layer that you can build on, regardless of programming language and framework.

achterliggende filosofie
- best-of-breed
- flexibiliteit: als iemand anders een ander systeem wil gebruiken kan dat, niet alles hoeft in één taal of één systeem geprogrammeerd te worden, men moet gewoon bv. ons zoek-component of auth-component inwerken.
- eigenlijk is het een toepassing van "program to an interface, not an implementation", maar op het niveau van al je web properties, eerder dan op het niveau van een individueel programma. Je neemt alle aspecten van je website in handen, eerder dan je neer te leggen bij wat een bepaald platform je biedt.

Dit gebeurt nu al, maar vooral door gebruik te maken van de publieke API's van allerlei diensten van Flickr tot AWS. Het gebeurt ook al bij zeer grote organisaties, die al langer hun gebruikersbeheer apart beheren (eventueel via ActiveDirectory of LDAP) en infrastructuur achter een abstractielaag steken (bv. DBSLayer bij de NYT) zodat verschillende technologieën makkelijker door elkaar gebruikt kunnen worden.

De evolutie die je dus volgens mij zal zien is dat er intern steeds nauwer naar interfaces zal geprogrammeerd worden (voorbeelden geven van onnodige koppelingen bv. door ruwe sql te gebruiken) en er private API's ontwikkeld zullen worden, en dat na de hoogdagen van 'extensibility' - plugins, modules, extensies - er ook hoogdagen komen voor 'pluggable backends'. Intern is dit nu reed seen mogelijkheid, maar zolang bestaande software niet 'meedenkt' in die richting blijft het de afweging of de ontwikkeling en onderhoud van allerlei wrappers en adapters niet meer moeite vraagt dan het omgaan met de ergernissen van een monolithisch platform.

Het probleem is dat de individuele componenten die we willen laten samenwerken, niet altijd even goed voorzien zijn op interactie met andere software, zodat er zelf nog heel wat programmeerwerk bij kan komen kijken.

Er zal dus nog héél wat moeten gebeuren om deze wereld van ubiquitous interfaces ook een valabele optie te maken voor kleinere organisaties — zoals het studentenblad waarover ik sprak — maar ik hoop echt dat deze manier van werken op den duur net zo eenvoudig en straightforward is als werken met een platform dat nu is, maar dan zonder de nadelen.

* Integreren met een externe authenticatie is meestal vrij makkelijk (grootteorde 20 à 50 lijnen code) als je alle applicaties die authenticatie uitvoeren vertrouwt (dwz. dat het wachtwoord direct wordt ingegeven bij de applicatie, die het dan checkt bij de bron -- wat minder veilig is dan de authenticatie volledig via de bron te laten verlopen zoals bij RPX of andere single-signon systemen), single sign-on over meerdere domeinen blijft nog steeds iets moeilijks waarvoor je logge systemen als Shibboleth nodig hebt.

* adapters ipv. extensies (cf. Newsroom)

* Externe search is relatief eenvoudig als je Apache Solr aanspreekt via HTTP (XML/REST)

* Geunifieerde look-and-feel is meestal niet het grootste probleem, maar is daarom niet noodzakelijk makkelijk op te lossen. Stel dat je website voor een groot stuk gebaseerd is rond Django, dan kan je andere Python-applicaties dezelfde base-templates laten gebruiken via Jinja2 en idem voor PHP-applicaties via "Calypso":http://www.beberlei.de/calypso/, maar een neutrale templating language die werkt in allerlei talen is het ook niet. Het gevolg is dat je dezelfde base-templates, maar met andere template tags naargelang het systeem, moet onderhouden. Een andere oplossing kan zijn om in je centrale website de externe apps 'in te plakken' en die applicaties enkel html-fragmenten te laten genereren ipv. volledige pagina's. Nog een andere oplossing is die van Deliverance. Op dat moment wordt het echter moeilijk om nog van volledig losgekoppelde componenten te spreken.

cf. Open Planning
cf. Facebook (http://developers.facebook.com/opensource.php) en hun werk voor Thrift en Scribe.
cf. ook DBSLayer van de NYT, die toelaat om alle load-balancing, sharding enz. te laten verlopen via deze layer en niet op het frameworkniveau, zodat élke applicatie die je maakt, van een bad-ass Rails-app tot een stom PHP-script tot een pareltje in Seaside, kan gebruik maken van dezelfde solide achterliggende databank-infrastructuur.

* werken met meerdere programmeertalen is geen probleem gezien het niet uitmaakt hoe een web service haar content genereert

* met Thrift kan je in principe automatisch zo'n interfaces laten genereren (zijn meestal zelfs geen web services denk ik)

check http://en.wikipedia.org/wiki/Thrift_(protocol) voor alternatieven zoals google Protocol Buffers -- infeite gaat het over verschillende aanpakken van Remote Procedure Calls (RPC), een probleem dat men natuurlijk al veel langer probeert op te lossen, van CORBA tot SOAP.

==> de discussie RPC versus RESTful services in webcontext
==> voor interne communicatie zou je de service enkel lokaal beschikbaar kunnen stellen voor bepaalde private IP-adressen, wat ook helpt bij de performantie (gezien trafiek verloopt via de loopback of het lokale netwerk) en misschien zelfs kan voldoen als enige beveiliging (tenzij IP spoofing een issue is)

* message queues als betrouwbaar transportmechanisme tussen verschillende systemen (intern)
* webhooks (extern)

Met interfaces verzorg je specifieke interacties tussen programma's (bv. een app vraagt user-informatie op, zorgt voor een login, …) zonder op de hoogte te moeten zijn van het specifieke datamodel of implementatie in het algemeen, met messaging zorg je dat gebeurtenissen waarop allerlei programma's kunnen of zouden willen reageren vrijelijk beschikbaar is.

Het ene is synchroon en je eist bepaalde resultaten, het andere is asynchroon en het is de verantwoordelijkheid van de luisteraars om iets te doen met de berichten die je geeft.

* permissies kunnen in één centrale interface geregeld worden, elke app moet gewoon de verschillende mogelijke permissie-instellingen doorgeven en checken of de ingelogde gebruiker toegang heeft.

* ook 'stomme' dingen zoals error reporting: "With a system where one of many components can fail, it’s important to keep track of these problems. If errors just end up in one of 10 log files, it’s unlikely anyone is closely tracking them."

* een upgrade van een systeem betekent niet meer een upgrade van héél je omgeving, want je zoekfunctionaliteit is losgekoppeld, je moet je gebruikers en hun profielinformatie niet mee-migreren, losstaande applicaties zoals een wiki (die anders misschien logininfo zouden 'leechen' van je belangrijkste applicatie en dus zouden falen bij een upgrade) worden niet beïnvloed. (Dit vereist uiteraard dat je auth-, index- en andere centrale applicaties minder snel wijzigen of je de implementatie backwards-compatible houdt, anders krijg je net zo goed problemen bij upgrades, maar dan "van de andere kant".)